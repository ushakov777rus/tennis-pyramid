"use client";

import { useEffect, useMemo, useState } from "react";
import { useParams } from "next/navigation";

import { PlayersRepository } from "@/app/repositories/PlayersRepository";
import { TournamentsRepository } from "@/app/repositories/TournamentsRepository";
import { TeamsRepository } from "@/app/repositories/TeamsRepository";

import { Participant } from "@/app/models/Participant";
import { Tournament } from "@/app/models/Tournament";
import { Team } from "@/app/models/Team";
import { Match } from "@/app/models/Match";

type RatingViewProps = { matches: Match[] };

export function RatingView({ matches }: RatingViewProps) {
  const params = useParams<{ id: string }>();
  const tournamentId = Number(params?.id);

  const [tournament, setTournament] = useState<Tournament | null>(null);
  const [participants, setParticipants] = useState<Participant[]>([]);
  const [teams, setTeams] = useState<Team[]>([]);
  const [loading, setLoading] = useState(true);

  async function loadData() {
    setLoading(true);
    const [t, tournamentParticipants, allTeams] = await Promise.all([
      TournamentsRepository.getTournamentById(tournamentId),
      TournamentsRepository.loadParticipants(tournamentId),
      TeamsRepository.loadAll(),
    ]);
    setTournament(t);
    setParticipants(tournamentParticipants);
    setTeams(allTeams);
    setLoading(false);
  }

  useEffect(() => {
    if (tournamentId) loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [tournamentId]);

  // ===== helpers =====
  const now = Date.now();
  const weekAgo = now - 7 * 24 * 60 * 60 * 1000;

  const getName = (p: Participant) =>
    p.player
      ? p.player.name
      : `${p.team?.player1?.name ?? "?"} + ${p.team?.player2?.name ?? "?"}`;

  const sideIds = (m: Match) => ({
    p1: m.player1?.id ?? m.team1?.id,
    p2: m.player2?.id ?? m.team2?.id,
  });

  const tookPart = (participantId: number, m: Match) => {
    const { p1, p2 } = sideIds(m);
    return p1 === participantId || p2 === participantId;
  };

  const isOnSide1 = (participantId: number, m: Match) =>
    (m.player1?.id ?? m.team1?.id) === participantId;

  const opponentOf = (participantId: number, m: Match): number | undefined => {
    const { p1, p2 } = sideIds(m);
    if (p1 === participantId) return p2;
    if (p2 === participantId) return p1;
    return undefined;
  };

  const winnerId = (m: Match) => m.getWinnerId?.();

  const pastMatches = (matches ?? []).filter(
    (m) => m?.date && m.date.getTime() <= now
  );

  // ===== –ª–∏–¥–µ—Ä—ã –ø–æ –Ω–æ–º–∏–Ω–∞—Ü–∏—è–º =====
  type LeadersRow = { title: string; winners: string[]; tooltip: string };

  const leaders = useMemo<LeadersRow[]>(() => {
    if (!participants.length) return [];

    const levelByPid = new Map<number, number | undefined>();
    for (const p of participants) levelByPid.set(p.id, p.level ?? undefined);

    // ü•ñ –ë—É–±–ª–∏–∫-–º–∞—Å—Ç–µ—Ä
    const bagelsByPid = new Map<number, number>();
    for (const p of participants) {
      let cnt = 0;
      for (const m of pastMatches) {
        if (!tookPart(p.getId, m)) continue;
        const on1 = isOnSide1(p.getId, m);
        for (const [a, b] of m.scores ?? []) {
          const my = on1 ? a : b;
          const opp = on1 ? b : a;
          if (my === 6 && opp === 0) {
            cnt++;
          }
        }
      }
      bagelsByPid.set(p.id, cnt);
    }

    const maxBagels = Math.max(...bagelsByPid.values(), 0);
    console.log("maxBagels:", maxBagels,bagelsByPid);
    const bagelWinners =
      maxBagels > 0
        ? participants
            .filter((p) => (bagelsByPid.get(p.id) ?? 0) === maxBagels)
            .map(getName)
        : [];

    // üß± –°—Ç–µ–Ω–∞ ‚Äî –≤–∏–Ω-—Å—Ç—Ä–∏–∫
    const streakByPid = new Map<number, number>();
    for (const p of participants) {
      const ms = pastMatches
        .filter((m) => tookPart(p.getId, m))
        .sort((a, b) => a.date.getTime() - b.date.getTime());
      let cur = 0;
      let best = 0;
      for (const m of ms) {
        const w = winnerId(m);
        if (!w) continue;
        if (w === p.getId) best = Math.max(best, ++cur);
        else cur = 0;
      }
      streakByPid.set(p.id, best);
    }
    const maxStreak = Math.max(...streakByPid.values(), 0);
    const wallWinners =
      maxStreak > 0
        ? participants
            .filter((p) => (streakByPid.get(p.id) ?? 0) === maxStreak)
            .map(getName)
        : [];

    // üêù –ì—Ä–∏–Ω–¥–µ—Ä ‚Äî –º–∞—Ç—á–∏ –∑–∞ 7 –¥–Ω–µ–π
    const recentCountByPid = new Map<number, number>();
    for (const p of participants) {
      let cnt = 0;
      for (const m of pastMatches) {
        
        if (tookPart(p.getId, m)) cnt++;
      }
      recentCountByPid.set(p.id, cnt);
    }
    const maxRecent = Math.max(...recentCountByPid.values(), 0);
    const grinderWinners =
      maxRecent > 0
        ? participants
            .filter((p) => (recentCountByPid.get(p.id) ?? 0) === maxRecent)
            .map(getName)
        : [];

    console.log("recentCountByPid:", recentCountByPid);

    // ‚ö° –£–¥–∞—á–ª–∏–≤—ã–π –Ω–∞–ø–∞–¥–∞—é—â–∏–π ‚Äî –±–æ–ª—å—à–µ –≤—Å–µ–≥–æ –ø–æ–±–µ–¥ –≤ —Ä–æ–ª–∏ –∞—Ç–∞–∫—É—é—â–µ–≥–æ
    const successfulAttacksByPid = new Map<number, number>();

    for (const p of participants) {
      let cnt = 0;
      for (const m of pastMatches) {
        if (!tookPart(p.getId, m)) continue;
        if (isOnSide1(p.getId, m) && winnerId(m) === p.getId) {
          cnt++;
        }
      }
      successfulAttacksByPid.set(p.id, cnt);
    }

    const maxSuccessfulAttacks = Math.max(...successfulAttacksByPid.values(), 0);
    const luckyAttackers =
      maxSuccessfulAttacks > 0
        ? participants
            .filter((p) => (successfulAttacksByPid.get(p.id) ?? 0) === maxSuccessfulAttacks)
            .map(getName)
        : [];

    // üôÉ –ù–µ—É–¥–∞—á–Ω—ã–π –Ω–∞–ø–∞–¥–∞—é—â–∏–π ‚Äî –±–æ–ª—å—à–µ –≤—Å–µ–≥–æ –ø–æ—Ä–∞–∂–µ–Ω–∏–π –≤ —Ä–æ–ª–∏ –∞—Ç–∞–∫—É—é—â–µ–≥–æ
    const failedAttacksByPid = new Map<number, number>();

    for (const p of participants) {
      let cnt = 0;
      for (const m of pastMatches) {
        if (!tookPart(p.getId, m)) continue;
        const onAttack = isOnSide1(p.getId, m);
        const w = winnerId(m);
        if (onAttack && w && w !== p.getId) {
          cnt++;
        }
      }
      failedAttacksByPid.set(p.id, cnt);
    }

    const maxFailedAttacks = Math.max(...failedAttacksByPid.values(), 0);
    const unluckyAttackers =
      maxFailedAttacks > 0
        ? participants
            .filter((p) => (failedAttacksByPid.get(p.id) ?? 0) === maxFailedAttacks)
            .map(getName)
        : [];

    // üé¢ –¢—Ä—ë—Ö—Å–µ—Ç–æ–≤—ã–π –±–æ–µ—Ü ‚Äî –±–æ–ª—å—à–µ –≤—Å–µ–≥–æ –º–∞—Ç—á–µ–π –≤ 3 —Å–µ—Ç–∞
    const threeSetMatchesByPid = new Map<number, number>();

    for (const p of participants) {
      let cnt = 0;
      for (const m of pastMatches) {
        if (!tookPart(p.getId, m)) continue;
        const setsCount = (m.scores ?? []).length;
        if (setsCount >= 3) cnt++;
      }
      threeSetMatchesByPid.set(p.id, cnt);
    }

    const maxThreeSet = Math.max(...threeSetMatchesByPid.values(), 0);
    const threeSetWarriors =
      maxThreeSet > 0
        ? participants
            .filter((p) => (threeSetMatchesByPid.get(p.id) ?? 0) === maxThreeSet)
            .map(getName)
        : [];


    // üõ° –ñ–µ–ª–µ–∑–Ω—ã–π –∑–∞—â–∏—Ç–Ω–∏–∫ ‚Äî –±–æ–ª—å—à–µ –≤—Å–µ–≥–æ –ø–æ–±–µ–¥ –≤ —Ä–æ–ª–∏ –∑–∞—â–∏—Ç–Ω–∏–∫–∞ (side 2)
    const defenseWinsByPid = new Map<number, number>();

    for (const p of participants) {
      let cnt = 0;
      for (const m of pastMatches) {
        if (!tookPart(p.getId, m)) continue;
        const onDefense = !isOnSide1(p.getId, m);
        if (onDefense && winnerId(m) === p.getId) {
          cnt++;
        }
      }
      defenseWinsByPid.set(p.id, cnt);
    }

    const maxDefenseWins = Math.max(...defenseWinsByPid.values(), 0);
    const ironDefenders =
      maxDefenseWins > 0
        ? participants
            .filter((p) => (defenseWinsByPid.get(p.id) ?? 0) === maxDefenseWins)
            .map(getName)
        : [];

    // ü™´ –ù–µ—É–¥–∞—á–Ω—ã–π –∑–∞—â–∏—Ç–Ω–∏–∫ ‚Äî –±–æ–ª—å—à–µ –≤—Å–µ–≥–æ –ø–æ—Ä–∞–∂–µ–Ω–∏–π –≤ –∑–∞—â–∏—Ç–µ (side 2)
    const defenseLossesByPid = new Map<number, number>();

    for (const p of participants) {
      let cnt = 0;
      for (const m of pastMatches) {
        if (!tookPart(p.getId, m)) continue;
        const onDefense = !isOnSide1(p.getId, m);
        const w = winnerId(m);
        if (onDefense && w && w !== p.getId) {
          cnt++;
        }
      }
      defenseLossesByPid.set(p.id, cnt);
    }

    const maxDefenseLosses = Math.max(...defenseLossesByPid.values(), 0);
    const unluckyDefenders =
      maxDefenseLosses > 0
        ? participants
            .filter((p) => (defenseLossesByPid.get(p.id) ?? 0) === maxDefenseLosses)
            .map(getName)
        : [];



    const rows: LeadersRow[] = [];
    if (bagelWinners.length)
      rows.push({
        title: "ü•ñ –ë—É–±–ª–∏–∫-–º–∞—Å—Ç–µ—Ä",
        winners: bagelWinners,
        tooltip: "–ë–æ–ª—å—à–µ –≤—Å–µ–≥–æ —Å–µ—Ç–æ–≤, –≤—ã–∏–≥—Ä–∞–Ω–Ω—ã—Ö 6:0.",
      });
    if (wallWinners.length)
      rows.push({
        title: "üß± –°—Ç–µ–Ω–∞",
        winners: wallWinners,
        tooltip: "–°–∞–º–∞—è –¥–ª–∏–Ω–Ω–∞—è —Å–µ—Ä–∏—è –ø–æ–±–µ–¥ –ø–æ–¥—Ä—è–¥.",
      });
    if (grinderWinners.length)
      rows.push({
        title: "üêù –ì—Ä–∏–Ω–¥–µ—Ä",
        winners: grinderWinners,
        tooltip: "–ë–æ–ª—å—à–µ –≤—Å–µ–≥–æ –º–∞—Ç—á–µ–π –∑–∞ —Ç—É—Ä–Ω–∏—Ä.",
      });
    if (luckyAttackers.length)
      rows.push({
        title: "‚ö° –£–¥–∞—á–ª–∏–≤—ã–π –Ω–∞–ø–∞–¥–∞—é—â–∏–π",
        winners: luckyAttackers,
        tooltip: "–ë–æ–ª—å—à–µ –≤—Å–µ–≥–æ –ø–æ–±–µ–¥ –≤ —Ä–æ–ª–∏ –∞—Ç–∞–∫—É—é—â–µ–≥–æ (–∏–≥—Ä–æ–∫ –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ player1/team1 –∏ –≤—ã–∏–≥—Ä–∞–ª –º–∞—Ç—á).",
      });
    if (unluckyAttackers.length)
      rows.push({
        title: "üôÉ –ù–µ—É–Ω—ã–≤–∞—é—â–∏–π –¥—Ä–∞—á—É–Ω",
        winners: unluckyAttackers,
        tooltip:
          "–ë–æ–ª—å—à–µ –≤—Å–µ–≥–æ –ø–æ—Ä–∞–∂–µ–Ω–∏–π –≤ —Ä–æ–ª–∏ –∞—Ç–∞–∫—É—é—â–µ–≥–æ (–∏–≥—Ä–æ–∫ –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ player1/team1 –∏ –ø—Ä–æ–∏–≥—Ä–∞–ª –º–∞—Ç—á).",
      });
    if (threeSetWarriors.length)
      rows.push({
        title: "üé¢ –¢—Ä—ë—Ö—Å–µ—Ç–æ–≤—ã–π –±–æ–µ—Ü",
        winners: threeSetWarriors,
        tooltip: "–ë–æ–ª—å—à–µ –≤—Å–µ–≥–æ –º–∞—Ç—á–µ–π, —Å—ã–≥—Ä–∞–Ω–Ω—ã—Ö –≤ 3 —Å–µ—Ç–∞.",
      });
    if (ironDefenders.length)
      rows.push({
        title: "üõ° –ñ–µ–ª–µ–∑–Ω—ã–π –∑–∞—â–∏—Ç–Ω–∏–∫",
        winners: ironDefenders,
        tooltip: "–ë–æ–ª—å—à–µ –≤—Å–µ–≥–æ –ø–æ–±–µ–¥, –∏–≥—Ä–∞—è –≤ –∑–∞—â–∏—Ç–µ (–∏–≥—Ä–æ–∫ –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ player2/team2).",
      });
    if (unluckyDefenders.length)
      rows.push({
        title: "ü™´ –ù–µ—É–¥–∞—á–Ω—ã–π –∑–∞—â–∏—Ç–Ω–∏–∫",
        winners: unluckyDefenders,
        tooltip: "–ë–æ–ª—å—à–µ –≤—Å–µ–≥–æ –ø–æ—Ä–∞–∂–µ–Ω–∏–π, –∏–≥—Ä–∞—è –≤ –∑–∞—â–∏—Ç–µ (–∏–≥—Ä–æ–∫ –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ player2/team2).",
      });

    return rows;
  }, [participants, pastMatches, weekAgo]);

  // ===== render =====
  if (loading) return <p>–ó–∞–≥—Ä—É–∑–∫–∞‚Ä¶</p>;
  if (!tournament) return <p>–¢—É—Ä–Ω–∏—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω</p>;

  return (
    <div className="history-wrap">
      <h3>üèÜ –î–æ—Å–∫–∞ –ø–æ—á—ë—Ç–∞ —Ç—É—Ä–Ω–∏—Ä–∞</h3>
      {leaders.length === 0 ? (
        <p>–ü–æ–∫–∞ –Ω–µ—Ç –ª–∏–¥–µ—Ä–æ–≤ ‚Äî —Å—ã–≥—Ä–∞–π—Ç–µ –µ—â—ë –Ω–µ–º–Ω–æ–≥–æ üòâ</p>
      ) : (
        <table className="history-table">
          <thead className="history-table-head">
            <tr>
              <th>–ò–≥—Ä–æ–∫(–∏)</th>
              <th>–¢–∏—Ç—É–ª</th>
            </tr>
          </thead>
          <tbody>
            {leaders.map((row, idx) =>
              row.winners.map((name) => (
                <tr key={`${idx}-${name}`}>
                  <td>{name}</td>
                  <td>
                    <span
                      className="badge-with-tip"
                      title={row.tooltip}
                    >
                      {row.title}
                    </span>
                  </td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      )}
    </div>
  );
}